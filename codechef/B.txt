PROBLEM:
You are given 
ğ´
,
ğµ
,
A,B, and 
ğ¾
K.
Starting with 
ğ‘¥
=
ğ¾
x=K, you can do the following:

ğ‘¥
â†’
ğ‘¥
+
1
xâ†’x+1
ğ‘¥
â†’
ğ¾
â‹…
ğ‘¥
xâ†’Kâ‹…x
Find the minimum number of moves needed to reach 
ğ‘¥
=
ğµ
x=B.

EXPLANATION:
Letâ€™s look at the process in reverse, i.e, starting from 
ğµ
B and reaching 
ğ´
A.
When doing this, we also need to invert the operations.

Instead of adding 
1
1 to 
ğ‘¥
x, we can subtract 
1
1 from it.
Instead of multiplying 
ğ‘¥
x by 
ğ¾
K, we can divide 
ğ‘¥
x by 
ğ¾
K, but only when 
ğ‘¥
x is already a multiple of 
ğ¾
K.
With this setup, note that whenever 
ğ‘¥
x is not a multiple of 
ğ¾
K, the only thing we can do is to subtract 
1
1.
So, letâ€™s repeatedly subtract 
1
1 till a multiple of 
ğ¾
K is reached.

When 
ğ‘¥
x is a multiple of 
ğ¾
K, we have two options: either subtract 
1
1 (in which case 
ğ‘¥
x is no longer a multiple of 
ğ¾
K again, so weâ€™re forced to keep subtracting till we reach the next smaller multiple), or divide by 
ğ¾
K.
Intuitively, it seems more useful to divide by 
ğ¾
K, since it moves us lower â€˜fasterâ€™ (as long as we donâ€™t undershoot 
ğ´
A by doing so, of course).
It turns out that this intuition is correct.

 Proof
tl;dr the following simple greedy works.
Start with 
ğ‘¥
=
ğµ
x=B. Then,

if 
ğ‘¥
x is a multiple of 
ğ¾
K and 
ğ‘¥
ğ¾
â‰¥
ğ´
K
x
â€‹
 â‰¥A, divide 
ğ‘¥
x by 
ğ¾
K.
If 
ğ‘¥
x is a multiple of 
ğ¾
K and 
ğ‘¥
ğ¾
<
ğ´
K
x
â€‹
 <A, use 
(
ğ‘¥
âˆ’
ğ´
)
(xâˆ’A) subtractions to reach 
ğ´
A.
If 
ğ‘¥
x is not a multiple of 
ğ¾
K, use subtractions to reach either 
ğ´
A or the next smallest multiple of 
ğ¾
K, whichever is closer.
To find the next smallest multiple of 
ğ¾
K, note that you can simply subtract 
(
ğ‘¥
â€Š
mod
â€Š
ğ¾
)
(xmodK) from 
ğ‘¥
x, so this can be computed in 
ğ‘‚
(
1
)
O(1).
Each division reduces 
ğ‘¥
x by a factor of 
ğ¾
K, so weâ€™ll perform at most 
log
â¡
ğ¾
ğµ
log 
K
â€‹
 B divisions (since that will put us at 
1
1 already).
Between divisions, the subtractions are simulated in 
ğ‘‚
(
1
)
O(1) time, so they donâ€™t affect the time complexity.